
/*
 * Feiyu gimbal hack
 *
 * Copyright (C) 2016 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */

 
//#include "settings.h"
#include "feiyu_uart.h"
#include "arm_linux.h"
#include "arm_math.h"
//#include "copter.h"
//#include "mpu9150.h"


// created by mathtables.c


const int16_t atan_table[] = {
// x=0-128 y=128
	0x0000, 0x0072, 0x00e5, 0x0157, 0x01ca, 0x023c, 0x02af, 0x0321, 
	0x0393, 0x0405, 0x0477, 0x04e9, 0x055b, 0x05cc, 0x063d, 0x06af, 
	0x0720, 0x0790, 0x0801, 0x0871, 0x08e1, 0x0951, 0x09c0, 0x0a2f, 
	0x0a9e, 0x0b0d, 0x0b7b, 0x0be9, 0x0c56, 0x0cc3, 0x0d30, 0x0d9d, 
	0x0e09, 0x0e74, 0x0ee0, 0x0f4b, 0x0fb5, 0x101f, 0x1088, 0x10f2, 
	0x115a, 0x11c2, 0x122a, 0x1291, 0x12f8, 0x135e, 0x13c4, 0x1429, 
	0x148e, 0x14f2, 0x1556, 0x15b9, 0x161c, 0x167e, 0x16df, 0x1740, 
	0x17a1, 0x1801, 0x1860, 0x18bf, 0x191d, 0x197b, 0x19d8, 0x1a34, 
	0x1a90, 0x1aec, 0x1b46, 0x1ba1, 0x1bfa, 0x1c53, 0x1cac, 0x1d04, 
	0x1d5b, 0x1db2, 0x1e08, 0x1e5e, 0x1eb3, 0x1f07, 0x1f5b, 0x1fae, 
	0x2001, 0x2053, 0x20a5, 0x20f5, 0x2146, 0x2196, 0x21e5, 0x2234, 
	0x2282, 0x22cf, 0x231c, 0x2369, 0x23b4, 0x2400, 0x244a, 0x2495, 
	0x24de, 0x2527, 0x2570, 0x25b8, 0x25ff, 0x2646, 0x268c, 0x26d2, 
	0x2718, 0x275c, 0x27a1, 0x27e4, 0x2827, 0x286a, 0x28ac, 0x28ee, 
	0x292f, 0x2970, 0x29b0, 0x29f0, 0x2a2f, 0x2a6d, 0x2aac, 0x2ae9, 
	0x2b27, 0x2b63, 0x2ba0, 0x2bdb, 0x2c17, 0x2c52, 0x2c8c, 0x2cc6, 
	0x2d00, 
// x=128 y=0-128
	0x5a00, 0x598d, 0x591a, 0x58a8, 0x5835, 0x57c3, 0x5750, 0x56de, 
	0x566c, 0x55fa, 0x5588, 0x5516, 0x54a4, 0x5433, 0x53c2, 0x5350, 
	0x52df, 0x526f, 0x51fe, 0x518e, 0x511e, 0x50ae, 0x503f, 0x4fd0, 
	0x4f61, 0x4ef2, 0x4e84, 0x4e16, 0x4da9, 0x4d3c, 0x4ccf, 0x4c62, 
	0x4bf6, 0x4b8b, 0x4b1f, 0x4ab4, 0x4a4a, 0x49e0, 0x4977, 0x490d, 
	0x48a5, 0x483d, 0x47d5, 0x476e, 0x4707, 0x46a1, 0x463b, 0x45d6, 
	0x4571, 0x450d, 0x44a9, 0x4446, 0x43e3, 0x4381, 0x4320, 0x42bf, 
	0x425e, 0x41fe, 0x419f, 0x4140, 0x40e2, 0x4084, 0x4027, 0x3fcb, 
	0x3f6f, 0x3f13, 0x3eb9, 0x3e5e, 0x3e05, 0x3dac, 0x3d53, 0x3cfb, 
	0x3ca4, 0x3c4d, 0x3bf7, 0x3ba1, 0x3b4c, 0x3af8, 0x3aa4, 0x3a51, 
	0x39fe, 0x39ac, 0x395a, 0x390a, 0x38b9, 0x3869, 0x381a, 0x37cb, 
	0x377d, 0x3730, 0x36e3, 0x3696, 0x364b, 0x35ff, 0x35b5, 0x356a, 
	0x3521, 0x34d8, 0x348f, 0x3447, 0x3400, 0x33b9, 0x3373, 0x332d, 
	0x32e7, 0x32a3, 0x325e, 0x321b, 0x31d8, 0x3195, 0x3153, 0x3111, 
	0x30d0, 0x308f, 0x304f, 0x300f, 0x2fd0, 0x2f92, 0x2f53, 0x2f16, 
	0x2ed8, 0x2e9c, 0x2e5f, 0x2e24, 0x2de8, 0x2dad, 0x2d73, 0x2d39, 
	0x2d00
	};
// static const int16_t sin_table[] = {
// 	0x0000, 0x0001, 0x0003, 0x0004, 0x0006, 0x0007, 0x0009, 0x000b, 
// 	0x000c, 0x000e, 0x000f, 0x0011, 0x0012, 0x0014, 0x0016, 0x0017, 
// 	0x0019, 0x001a, 0x001c, 0x001d, 0x001f, 0x0021, 0x0022, 0x0024, 
// 	0x0025, 0x0027, 0x0028, 0x002a, 0x002b, 0x002d, 0x002f, 0x0030, 
// 	0x0032, 0x0033, 0x0035, 0x0036, 0x0038, 0x0039, 0x003b, 0x003c, 
// 	0x003e, 0x003f, 0x0041, 0x0043, 0x0044, 0x0046, 0x0047, 0x0049, 
// 	0x004a, 0x004c, 0x004d, 0x004f, 0x0050, 0x0052, 0x0053, 0x0055, 
// 	0x0056, 0x0058, 0x0059, 0x005b, 0x005c, 0x005d, 0x005f, 0x0060, 
// 	0x0062, 0x0063, 0x0065, 0x0066, 0x0068, 0x0069, 0x006a, 0x006c, 
// 	0x006d, 0x006f, 0x0070, 0x0072, 0x0073, 0x0074, 0x0076, 0x0077, 
// 	0x0079, 0x007a, 0x007b, 0x007d, 0x007e, 0x0080, 0x0081, 0x0082, 
// 	0x0084, 0x0085, 0x0086, 0x0088, 0x0089, 0x008a, 0x008c, 0x008d, 
// 	0x008e, 0x0090, 0x0091, 0x0092, 0x0093, 0x0095, 0x0096, 0x0097, 
// 	0x0099, 0x009a, 0x009b, 0x009c, 0x009e, 0x009f, 0x00a0, 0x00a1, 
// 	0x00a2, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00aa, 0x00ab, 
// 	0x00ac, 0x00ad, 0x00ae, 0x00af, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 
// 	0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00bb, 0x00bc, 0x00bd, 
// 	0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 
// 	0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 
// 	0x00ce, 0x00cf, 0x00d0, 0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 
// 	0x00d5, 0x00d6, 0x00d7, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db, 
// 	0x00dc, 0x00dc, 0x00dd, 0x00de, 0x00df, 0x00e0, 0x00e0, 0x00e1, 
// 	0x00e2, 0x00e3, 0x00e3, 0x00e4, 0x00e5, 0x00e5, 0x00e6, 0x00e7, 
// 	0x00e7, 0x00e8, 0x00e9, 0x00e9, 0x00ea, 0x00eb, 0x00eb, 0x00ec, 
// 	0x00ec, 0x00ed, 0x00ee, 0x00ee, 0x00ef, 0x00ef, 0x00f0, 0x00f0, 
// 	0x00f1, 0x00f1, 0x00f2, 0x00f2, 0x00f3, 0x00f3, 0x00f4, 0x00f4, 
// 	0x00f5, 0x00f5, 0x00f6, 0x00f6, 0x00f7, 0x00f7, 0x00f7, 0x00f8, 
// 	0x00f8, 0x00f9, 0x00f9, 0x00f9, 0x00fa, 0x00fa, 0x00fa, 0x00fb, 
// 	0x00fb, 0x00fb, 0x00fb, 0x00fc, 0x00fc, 0x00fc, 0x00fc, 0x00fd, 
// 	0x00fd, 0x00fd, 0x00fd, 0x00fe, 0x00fe, 0x00fe, 0x00fe, 0x00fe, 
// 	0x00fe, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 
// 	0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x00ff, 0x0100,
// 	0x0100 };

// greater precision is required for the motor table
const int16_t sin_table[] = {
        0x0000, 0x0064, 0x00c9, 0x012d, 0x0192, 0x01f6, 0x025b, 0x02bf, 
        0x0323, 0x0388, 0x03ec, 0x0451, 0x04b5, 0x0519, 0x057d, 0x05e1, 
        0x0645, 0x06a9, 0x070d, 0x0771, 0x07d5, 0x0839, 0x089c, 0x0900, 
        0x0964, 0x09c7, 0x0a2a, 0x0a8d, 0x0af1, 0x0b54, 0x0bb6, 0x0c19, 
        0x0c7c, 0x0cde, 0x0d41, 0x0da3, 0x0e05, 0x0e67, 0x0ec9, 0x0f2b, 
        0x0f8c, 0x0fee, 0x104f, 0x10b0, 0x1111, 0x1172, 0x11d3, 0x1233, 
        0x1294, 0x12f4, 0x1354, 0x13b3, 0x1413, 0x1472, 0x14d1, 0x1530, 
        0x158f, 0x15ee, 0x164c, 0x16aa, 0x1708, 0x1766, 0x17c3, 0x1820, 
        0x187d, 0x18da, 0x1937, 0x1993, 0x19ef, 0x1a4b, 0x1aa6, 0x1b02, 
        0x1b5d, 0x1bb7, 0x1c12, 0x1c6c, 0x1cc6, 0x1d20, 0x1d79, 0x1dd2, 
        0x1e2b, 0x1e83, 0x1edc, 0x1f34, 0x1f8b, 0x1fe2, 0x2039, 0x2090, 
        0x20e7, 0x213d, 0x2192, 0x21e8, 0x223d, 0x2292, 0x22e6, 0x233a, 
        0x238e, 0x23e1, 0x2434, 0x2487, 0x24da, 0x252c, 0x257d, 0x25cf, 
        0x261f, 0x2670, 0x26c0, 0x2710, 0x275f, 0x27af, 0x27fd, 0x284b, 
        0x2899, 0x28e7, 0x2934, 0x2981, 0x29cd, 0x2a19, 0x2a65, 0x2ab0, 
        0x2afa, 0x2b45, 0x2b8e, 0x2bd8, 0x2c21, 0x2c6a, 0x2cb2, 0x2cf9, 
        0x2d41, 0x2d88, 0x2dce, 0x2e14, 0x2e5a, 0x2e9f, 0x2ee3, 0x2f28, 
        0x2f6b, 0x2faf, 0x2ff1, 0x3034, 0x3076, 0x30b7, 0x30f8, 0x3138, 
        0x3179, 0x31b8, 0x31f7, 0x3236, 0x3274, 0x32b1, 0x32ee, 0x332b, 
        0x3367, 0x33a3, 0x33de, 0x3419, 0x3453, 0x348c, 0x34c6, 0x34fe, 
        0x3536, 0x356e, 0x35a5, 0x35dc, 0x3612, 0x3647, 0x367c, 0x36b1, 
        0x36e5, 0x3718, 0x374b, 0x377d, 0x37af, 0x37e0, 0x3811, 0x3841, 
        0x3871, 0x38a0, 0x38cf, 0x38fd, 0x392a, 0x3957, 0x3983, 0x39af, 
        0x39da, 0x3a05, 0x3a2f, 0x3a59, 0x3a82, 0x3aaa, 0x3ad2, 0x3afa, 
        0x3b20, 0x3b47, 0x3b6c, 0x3b91, 0x3bb6, 0x3bda, 0x3bfd, 0x3c20, 
        0x3c42, 0x3c63, 0x3c84, 0x3ca5, 0x3cc5, 0x3ce4, 0x3d02, 0x3d21, 
        0x3d3e, 0x3d5b, 0x3d77, 0x3d93, 0x3dae, 0x3dc9, 0x3de2, 0x3dfc, 
        0x3e14, 0x3e2d, 0x3e44, 0x3e5b, 0x3e71, 0x3e87, 0x3e9c, 0x3eb1, 
        0x3ec5, 0x3ed8, 0x3eeb, 0x3efd, 0x3f0e, 0x3f1f, 0x3f2f, 0x3f3f, 
        0x3f4e, 0x3f5d, 0x3f6a, 0x3f78, 0x3f84, 0x3f90, 0x3f9c, 0x3fa6, 
        0x3fb1, 0x3fba, 0x3fc3, 0x3fcb, 0x3fd3, 0x3fda, 0x3fe1, 0x3fe7, 
        0x3fec, 0x3ff0, 0x3ff4, 0x3ff8, 0x3ffb, 0x3ffd, 0x3ffe, 0x3fff,
		0x4000
};


const int16_t tan_table[] = {
	0x0000, 0x0001, 0x0003, 0x0004, 0x0006, 0x0007, 0x0009, 0x000b, 
	0x000c, 0x000e, 0x000f, 0x0011, 0x0012, 0x0014, 0x0016, 0x0017, 
	0x0019, 0x001a, 0x001c, 0x001e, 0x001f, 0x0021, 0x0022, 0x0024, 
	0x0026, 0x0027, 0x0029, 0x002a, 0x002c, 0x002e, 0x002f, 0x0031, 
	0x0033, 0x0034, 0x0036, 0x0038, 0x0039, 0x003b, 0x003d, 0x003e, 
	0x0040, 0x0042, 0x0043, 0x0045, 0x0047, 0x0048, 0x004a, 0x004c, 
	0x004d, 0x004f, 0x0051, 0x0053, 0x0054, 0x0056, 0x0058, 0x005a, 
	0x005b, 0x005d, 0x005f, 0x0061, 0x0063, 0x0064, 0x0066, 0x0068, 
	0x006a, 0x006c, 0x006e, 0x0070, 0x0071, 0x0073, 0x0075, 0x0077, 
	0x0079, 0x007b, 0x007d, 0x007f, 0x0081, 0x0083, 0x0085, 0x0087, 
	0x0089, 0x008b, 0x008d, 0x008f, 0x0091, 0x0093, 0x0095, 0x0098, 
	0x009a, 0x009c, 0x009e, 0x00a0, 0x00a2, 0x00a5, 0x00a7, 0x00a9, 
	0x00ab, 0x00ae, 0x00b0, 0x00b2, 0x00b5, 0x00b7, 0x00b9, 0x00bc, 
	0x00be, 0x00c1, 0x00c3, 0x00c6, 0x00c8, 0x00cb, 0x00ce, 0x00d0, 
	0x00d3, 0x00d5, 0x00d8, 0x00db, 0x00de, 0x00e0, 0x00e3, 0x00e6, 
	0x00e9, 0x00ec, 0x00ef, 0x00f2, 0x00f5, 0x00f8, 0x00fb, 0x00fe, 
	0x0101, 0x0104, 0x0108, 0x010b, 0x010e, 0x0111, 0x0115, 0x0118, 
	0x011c, 0x011f, 0x0123, 0x0127, 0x012a, 0x012e, 0x0132, 0x0136, 
	0x013a, 0x013e, 0x0142, 0x0146, 0x014a, 0x014e, 0x0152, 0x0157, 
	0x015b, 0x0160, 0x0164, 0x0169, 0x016e, 0x0173, 0x0178, 0x017d, 
	0x0182, 0x0187, 0x018c, 0x0192, 0x0197, 0x019d, 0x01a3, 0x01a9, 
	0x01af, 0x01b5, 0x01bb, 0x01c1, 0x01c8, 0x01ce, 0x01d5, 0x01dc, 
	0x01e3, 0x01eb, 0x01f2, 0x01fa, 0x0202, 0x020a, 0x0212, 0x021a, 
	0x0223, 0x022c, 0x0235, 0x023e, 0x0248, 0x0252, 0x025c, 0x0267, 
	0x0272, 0x027d, 0x0288, 0x0294, 0x02a1, 0x02ad, 0x02ba, 0x02c8, 
	0x02d6, 0x02e5, 0x02f4, 0x0303, 0x0313, 0x0324, 0x0336, 0x0348, 
	0x035b, 0x036f, 0x0383, 0x0399, 0x03af, 0x03c7, 0x03df, 0x03f9, 
	0x0415, 0x0431, 0x044f, 0x046f, 0x0490, 0x04b4, 0x04d9, 0x0501, 
	0x052c, 0x0559, 0x0589, 0x05bd, 0x05f4, 0x0630, 0x0671, 0x06b6, 
	0x0702, 0x0755, 0x07af, 0x0813, 0x0881, 0x08fb, 0x0983, 0x0a1c, 
	0x0aca, 0x0b91, 0x0c75, 0x0d80, 0x0ebc, 0x1036, 0x1204, 0x1446, 
	0x172d, 0x1b0b, 0x2075, 0x2893, 0x361b, 0x512a, 0x7f00, 0x7f00,
	0x7fff };






int mul_fixed(int x, int y)
{
	return x * y / FRACTION;
}

int tan_fixed(int angle)
{
	while(angle < 0) angle += 360 * FRACTION;
	while(angle >= 360 * FRACTION) angle -= 360 * FRACTION;

// 0 - 90
	if(angle <= 90 * FRACTION)
	{
		int index = angle / 90;
		return tan_table[index];
	}
	else
// 90 - 180
	if(angle <= 180 * FRACTION)
	{
		int index = FRACTION - (angle - 90 * FRACTION) / 90;
		return -tan_table[index];
	}
	else
// 180 - 270
	if(angle <= 270 * FRACTION)
	{
		int index = (angle - 180 * FRACTION) / 90;
		return tan_table[index];
	}
	else
// 270 - 360
	{
		int index = FRACTION - (angle - 270 * FRACTION) / 90;
		return -tan_table[index];
	}
}

int atan2_fixed(int y, int x)
{
	int x_abs = abs_fixed(x);
	int y_abs = abs_fixed(y);
	int angle = 0;

// normalize
	if(x_abs == 0 && y_abs == 0)
	{
		return 0;
	}
	else
	if(x_abs >= y_abs)
	{
		int y_normalized = y_abs * 128 / x_abs;
		CLAMP(y_normalized, 0, 128);
		angle = atan_table[y_normalized];
	}
	else
	{
		int x_normalized = x_abs * 128 / y_abs;
		CLAMP(x_normalized, 0, 128);
		angle = atan_table[129 + x_normalized];
	}

	if(y >= 0 && x >= 0) 
		return angle;
	else
	if(y <= 0 && x >= 0)
		return -angle;
	else
	if(y >= 0 && x <= 0)
		return 180 * FRACTION - angle;
	else
		return -180 * FRACTION + angle;

}


// get the table sign & index
void sin_index(int *sign, int *index, int angle)
{
	while(angle < 0) angle += 360 * FRACTION;
	while(angle >= 360 * FRACTION) angle -= 360 * FRACTION;

// 270 - 360
	if(angle >= 270 * FRACTION)
	{
		*index = (360 * FRACTION - angle) / 90;
		*sign = -1;
	}
	else
// 180 - 270
	if(angle >= 180 * FRACTION)
	{
		*index = (angle - 180 * FRACTION) / 90;
		*sign = -1;
	}
	else
// 90 - 180
	if(angle >= 90 * FRACTION)
	{
		*index = (180 * FRACTION - angle) / 90;
		*sign = 1;
	}
	else
// 0 - 90
	{
		*index = angle / 90;
		*sign = 1;
	}
}

int sin_fixed(int angle)
{
	int sign, index;
	sin_index(&sign, &index, angle);
	return sign * sin_table[index] >> 6;
}

int sin_fixed14(int angle)
{
	int sign, index;
	sin_index(&sign, &index, angle);
	return sign * sin_table[index];
}





int cos_fixed(int angle)
{
	return sin_fixed(angle + 90 * FRACTION);
}


#if 0
void euler_dc(matrix_t *dst, vector_t *euler)
{
	int	cpsi;
	int	cphi;
	int	ctheta;

	int	spsi;
	int	sphi;
	int	stheta;

	if(euler->x == 0 && euler->y == 0)
	{
		cpsi	= 1 * FRACTION;
		cphi	= 1 * FRACTION;
		ctheta	= 1 * FRACTION;

		spsi	= 0 * FRACTION;
		sphi	= 0 * FRACTION;
		stheta	= 0 * FRACTION;
	}
	else
	{
		int phi = -euler->y;
		int theta	= euler->x;
		int psi = euler->z;

		cpsi	= cos_fixed(psi);
		cphi	= cos_fixed(phi);
		ctheta	= cos_fixed(theta);

		spsi	= sin_fixed(psi);
		sphi	= sin_fixed(phi);
		stheta	= sin_fixed(theta);
	}


	MATRIX_ENTRY(*dst, 0, 0) = mul_fixed(cpsi, ctheta);
	MATRIX_ENTRY(*dst, 0, 1) = mul_fixed(spsi, ctheta);
	MATRIX_ENTRY(*dst, 0, 2) = -stheta;

	MATRIX_ENTRY(*dst, 1, 0) = mul_fixed(-spsi, cphi) + mul_fixed(mul_fixed(cpsi, stheta), sphi);
	MATRIX_ENTRY(*dst, 1, 1) = mul_fixed(cpsi, cphi) + mul_fixed(mul_fixed(spsi, stheta), sphi);
	MATRIX_ENTRY(*dst, 1, 2) = mul_fixed(ctheta, sphi);

	MATRIX_ENTRY(*dst, 2, 0) = mul_fixed(spsi, sphi) + mul_fixed(mul_fixed(cpsi, stheta), cphi);
	MATRIX_ENTRY(*dst, 2, 1) = mul_fixed(-cpsi, sphi) + mul_fixed(mul_fixed(spsi, stheta), cphi);
	MATRIX_ENTRY(*dst, 2, 2) = mul_fixed(ctheta, cphi);
}

void transpose_matrix(matrix_t *dst, 
	matrix_t *src)
{
	int i, j;


	for(i = 0; i < src->rows; i++)
	{
		int *src_row = MATRIX_ROW(*src, i);
		for(j = 0; j < src->columns; j++)
			MATRIX_ENTRY(*dst, j, i) = src_row[j];
	}
}



void distance_angle(int *distance, 
	int *angle, 
	int x1,
	int y1,
	int x2, 
	int y2)
{
	*distance = 0;
	*angle = 0;

	if(x1 == x2 && y1 == y2)
	{
		return;
	}

	*angle = atan2_fixed(y2 - y1, x2 - x1);
	if(abs_fixed(x2 - x1) > abs_fixed(y2 - y1))
	{
		*distance = (x2 - x1) * FRACTION / cos_fixed(*angle);
	}
	else
	{
		*distance = (y2 - y1) * FRACTION / sin_fixed(*angle);
	}
	
}
#endif // 0




void multiply_matrix_vector(vector_t *dst, matrix_t *mat, vector_t *vec)
{
	int i, j;
	int n = mat->rows;
	int m = mat->columns;


	for(i = 0; i < n; i++)
	{
		int s = 0;
		for(j = 0; j < m; j++)
			s += mul_fixed(MATRIX_ENTRY(*mat, i, j), VECTOR_ENTRY(*vec, j));
		VECTOR_ENTRY(*dst, i) = s;
	}
}

void print_matrix(matrix_t *mat)
{
	int i, j;
	print_lf(&uart);
	for(i = 0; i < mat->rows; i++)
	{
		for(j = 0; j < mat->rows; j++)
		{
			print_fixed(&uart, MATRIX_ENTRY(*mat, i, j));
		}
		print_lf(&uart);
	}
}

void print_vector(vector_t *vec)
{
	int i, j;
	for(i = 0; i < vec->size; i++)
	{
		print_fixed(&uart, VECTOR_ENTRY(*vec, i));
	}
	print_lf(&uart);
}






int get_angle_change(int old_angle, int new_angle)
{
	int result = new_angle - old_angle;
	if(result > 180) result -= 360;
	else
	if(result < -180) result += 360;
	return result;
}


int get_angle_change_fixed(int old_angle, int new_angle)
{
	int result = new_angle - old_angle;
	if(result > 180 * FRACTION) result -= 360 * FRACTION;
	else
	if(result < -180 * FRACTION) result += 360 * FRACTION;
	return result;
}

int fix_angle(int angle)
{
	if(angle > 180 * FRACTION) angle -= 360 * FRACTION;
	if(angle < -180 * FRACTION) angle += 360 * FRACTION;
	return angle;
}



// Zero derivative structure
void init_derivative(derivative_t *ptr, int buffer_size)
{
	bzero(ptr->prev, buffer_size * sizeof(int));
	ptr->total = buffer_size;
	ptr->index = 0;
}

void reset_derivative(derivative_t *ptr)
{
//printf("reset_derivative %d: allocated=%d\n", __LINE__, ptr->allocated);
	bzero(ptr->prev, ptr->total * sizeof(int));
	ptr->index = 0;
}


// Push new value on derivative buffer
void update_derivative(derivative_t *ptr, int value)
{
	ptr->prev[ptr->index] = value;
	ptr->index++;
	if(ptr->index >= ptr->total) ptr->index = 0;
	
}


// Get derivative
int get_derivative(derivative_t *ptr)
{
	int current_index = ptr->index - 1;
	if(current_index < 0) current_index = ptr->total - 1;
	return ptr->prev[current_index] - ptr->prev[ptr->index];
}

// get sum of all values
int get_sum(derivative_t *ptr)
{
	int i;
	int sum = 0;

	for(i = 0; i < ptr->total; i++)
	{
		sum += ptr->prev[i];
	}
	
	return sum;
}



