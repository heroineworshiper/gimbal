#include "stm32f1xx_hal_dma.h"
#include "stm32f1xx_hal_gpio.h"
#include "stm32f1xx_hal_rcc.h"
#include "stm32f1xx_hal_tim.h"

#include "feiyu_mane.h"
#include "feiyu_adc.h"
#include "feiyu_hall.h"
#include "feiyu_motor.h"
#include "feiyu_uart.h"
#include "arm_math.h"
#include "arm_linux.h"

motor_t motor;

TIM_HandleTypeDef TimHandle;
TIM_OC_InitTypeDef sConfig;

#define N_MOSFET_PIN1 13
#define N_MOSFET_PIN2 14
#define N_MOSFET_PIN3 15
#define N_MOSFET_GPIO GPIOB

#define P_MOSFET_PIN1 8
#define P_MOSFET_PIN2 9
#define P_MOSFET_PIN3 10
#define P_MOSFET_GPIO GPIOA

#define PERIOD 3600
#define MIN_DEADBAND 196
// PERIOD - PWM cutoff value
#define MAX_SIN PERIOD
// PWM cutoff value
#define MIN_SIN 1



#define N_SIN 512
static uint16_t motor_table[N_SIN];

// need a different table for each motor, since the voltage reaching the motor
// is lower than the voltage reaching the ADC, depending on how many motors it's 
// passing to.  Try getting current sensors to work.

// deadband vs. battery for 2.4W, BOARD2
const uint16_t deadband_table[] = 
{
	1025, 217, // 6V 0.4A
	1200, 233, // 7V 0.34A
	1450, 243, // 8V 0.3A
	1666, 250, // 9V 0.27A
	1800, 255, // 10V, 0.24A
};

#define WAVEFORM_SIZE (sizeof(motor_table) / sizeof(uint16_t))
#define DEADBAND_ENTRIES (sizeof(deadband_table) / sizeof(uint16_t) / 2)


// anti cogging table generated by motor_test()

#ifndef CALIBRATE_MOTOR

const char index_offset[] =
{
	0, 10, 12, 12, 13, 14, 15, 15, 16, 16, 17, 17, 17, 17, 17, 17, 
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 16, 15, 16, 15, 14, 13, 
	13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 13, 
	13, 13, 13, 12, 12, 12, 12, 12, 11, 11, 11, 11, 10, 10, 10, 9, 
	9, 8, 8, 8, 14, 16, 16, 15, 15, 15, 15, 15, 19, 21, 21, 21, 
	21, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 
	17, 17, 17, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 
	15, 15, 15, 14, 14, 14, 13, 13, 12, 12, 11, 10, 10, 9, 8, 8, 
	7, 6, 5, 4, 4, 3, 2, 1, 1, 0, 0, -1, -1, -2, -3, -3, 
	-4, -5, -6, -7, -7, -8, -9, -10, -11, -11, -12, -13, -13, -14, -14, -15, 
	-15, -16, -16, -16, -16, -17, -17, -17, -17, -17, -17, -17, -17, -18, -18, -18, 
	-18, -18, -18, -11, -11, -11, -11, -11, -11, -7, -3, -3, -4, -4, -4, -5, 
	-5, -5, -6, -6, -6, -6, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, 
	-7, -7, -7, -7, -7, -7, -6, -6, -6, -6, -6, -6, -7, -6, -7, -8, 
	-7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, 
	-7, -7, -6, -6, -6, -6, -5, -4, -3, 6, 7, 8, 15, 17, 18, 19, 
	20, 21, 21, 22, 23, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 25, 
	25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 24, 30, 31, 30, 30, 30, 29, 29, 29, 31, 37, 36, 36, 36, 
	35, 35, 34, 34, 33, 32, 32, 31, 31, 30, 30, 30, 30, 30, 29, 29, 
	29, 29, 28, 28, 27, 27, 26, 25, 25, 24, 24, 23, 23, 22, 22, 21, 
	21, 20, 19, 19, 18, 17, 16, 16, 15, 14, 13, 13, 12, 11, 11, 10, 
	9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 
	1, 1, 1, 0, 0, 0, -1, -1, -1, -2, -2, -2, -3, -3, -4, -4, 
	-4, -5, -5, -6, -6, -7, -7, -7, -8, -8, -9, -9, -10, -10, -11, -11, 
	-12, -12, -13, -13, -14, -14, -15, -15, -15, -16, -16, -17, -17, -17, -18, -18, 
	-18, -19, -19, -19, -17, -11, -11, -11, -12, -12, -12, -13, -13, -13, -7, -7, 
	-7, -7, -7, -7, -7, -7, -7, -7, -8, -8, -8, -8, -9, -9, -9, -9, 
	-9, -9, -9, -9, -9, -9, -8, -8, -8, -8, -7, -7, -7, -7, -7, -7, 
	-7, -7, -7, -7, -7, -6, -7, -6, -7, -6, -7, -7, -7, -7, -7, -7, 
	-8, -8, -8, -8, -8, -8, -8, -8, -9, -9, -9, -9, -9, -4, -2, -2
};


#endif //  !CALIBRATE_MOTOR


void print_phase(int value)
{
	int scaled = value * 79 / PERIOD;
	int i;
	for(i = 0; i < scaled; i++)
	{
		send_uart(&uart, "#", 1);
	}
	for(i = scaled; i < 79; i++)
	{
		send_uart(&uart, " ", 1);
	}
	print_lf(&uart);
}

void print_phases()
{
//	const char *clear_screen = "\033[2J";
//	send_uart(&uart, clear_screen, strlen(clear_screen));
	TRACE
	print_number(&uart, fei.test_period);
	send_uart(&uart, "     ", 5);
	print_lf(&uart);
	print_phase(TimHandle.Instance->CCR1);
	print_phase(TimHandle.Instance->CCR2);
	print_phase(TimHandle.Instance->CCR3);


	const char *cursor_up = "\033[4A";
	send_uart(&uart, cursor_up, strlen(cursor_up));
	flush_uart(&uart);
}


#define FIX_PHASE(x) \
	while(x < 0) x += 360 * FRACTION; \
	while(x >= 360 * FRACTION) x -= 360 * FRACTION;
#define CALCULATE_WAVEFORM(x) ((uint32_t)motor_table[x] * (max_sin - min_sin) / 65535 + min_sin)

// set the PWM values for the phase
void write_motor()
{
	FIX_PHASE(motor.phase)
	CLAMP(motor.power, 0, MAX_POWER);

// disable this to calculate the anti cogging table
//#ifndef CALIBRATE_MOTOR

//	int phase_offset_index = motor.phase * N_SIN / 360 / FRACTION;
//	int phase_offset = phase_offset[phase_offset_index];
//	int fixed_phase = motor.phase + phase_offset;

//TRACE
//print_fixed(&uart, motor.phase);
//print_fixed(&uart, fixed_phase);\

//#else
//	int fixed_phase = motor.phase;

//#endif


	
	int max_sin = MAX_SIN - (MAX_POWER - motor.power);
	int min_sin = MIN_SIN + (MAX_POWER - motor.power);
	int index1 = (motor.phase * WAVEFORM_SIZE / 360 / FRACTION) % WAVEFORM_SIZE;

#ifndef CALIBRATE_MOTOR
TRACE
print_number(&uart, index1);
	int index_offset_ = index_offset[index1];
	if(index_offset_ >= 0x80)
	{
		index_offset_ -= 0x100;
	}
	index1 += index_offset_;
	index1 %= WAVEFORM_SIZE;
print_number(&uart, index1);
#endif

	int index2 = (index1 + 120 * WAVEFORM_SIZE / 360) % WAVEFORM_SIZE;
	int index3 = (index1 + 240 * WAVEFORM_SIZE / 360) % WAVEFORM_SIZE;

//print_number(&uart, motor.phase / FRACTION);
//print_number(&uart, fixed_phase / FRACTION);
//print_number(&uart, hall.value);

	TimHandle.Instance->CCR1 = CALCULATE_WAVEFORM(index1);
	TimHandle.Instance->CCR2 = CALCULATE_WAVEFORM(index2);
	TimHandle.Instance->CCR3 = CALCULATE_WAVEFORM(index3);

//print_number(&uart, TimHandle.Instance->CCR1);
//print_number(&uart, TimHandle.Instance->CCR2);
//print_number(&uart, TimHandle.Instance->CCR3);

//TRACE
//print_number(&uart, index1);
//print_number(&uart, CALCULATE_WAVEFORM(index1));
//print_number(&uart, CALCULATE_WAVEFORM(index2));
//print_number(&uart, CALCULATE_WAVEFORM(index3));
//	print_phases();
}

#if 0
void update_deadband()
{
	if(adc.battery > 0)
	{
		int i;
		int new_deadband = 0;
		if(adc.battery_avg <= deadband_table[0])
		{
			new_deadband = deadband_table[1];
		}
		else
		if(adc.battery_avg >= deadband_table[DEADBAND_ENTRIES * 2 - 2])
		{
			new_deadband = deadband_table[DEADBAND_ENTRIES * 2 - 1];
		}
		else
		{
			for(i = 0; i < DEADBAND_ENTRIES; i++)
			{
				if(adc.battery_avg < deadband_table[i * 2])
				{
					int deadband1 = deadband_table[i * 2 - 1];
					int deadband2 = deadband_table[i * 2 + 1];
					int voltage1 = deadband_table[i * 2 - 2];
					int voltage2 = deadband_table[i * 2];
					new_deadband = (adc.battery_avg - voltage1) *
						(deadband2 - deadband1) / 
						(voltage2 - voltage1) +
						deadband1;
					break;
				}
			}
		}
		
		if(new_deadband > motor.deadband)
		{
			motor.deadband++;
		}
		else
		if(new_deadband < motor.deadband)
		{
			motor.deadband--;
		}



TRACE
print_number(&uart, adc.battery_avg);
print_number(&uart, new_deadband);



	}
}
#endif // 0


#if 0
int hall_to_phase(int hall)
{
#ifdef BOARD2
	int64_t min_hall = 17670;
	int64_t min_phase = 115;
	int64_t hall_delta = 30869 - 19160;
	int64_t phase_delta = 5 * 360;
	int result = (int64_t)min_phase * FRACTION + 
		(int64_t)(hall - min_hall) * phase_delta * FRACTION / hall_delta;
#endif


	FIX_PHASE(result);
	return result;
}

// search for position based on hall effect sensor
void update_motor()
{
/*
 * if(UART_EMPTY(&uart))
 * {
 * TRACE
 * print_number(&uart, hall.value - motor.hall);
 * }
 */

	if(ABS(hall.value - motor.hall) < 1000)
	{
		int error = hall.value - motor.hall;
		update_derivative(&motor.derror, error);
		int value = do_pid(&motor.pid, 
			hall.value - motor.hall, 
			get_derivative(&motor.derror));

//if(UART_EMPTY(&uart))
//{
//TRACE
//print_number(&uart, error);
//print_number(&uart, value);
//print_number(&uart, get_derivative(&motor.derror));
//}

		motor.phase -= value;
		write_motor();
	}
	else
	{
		int current_phase = hall_to_phase(hall.value);
		if(motor.hall > hall.value)
		{
			reset_pid(&motor.pid);
			motor.phase = current_phase + 120 * FRACTION;
			write_motor();
		}
		else
		{
			reset_pid(&motor.pid);
			motor.phase = current_phase - 120 * FRACTION;
			write_motor();
		}
	}
}
#endif // 0

#ifdef CALIBRATE_MOTOR

// develop the anti cogging table
void motor_test()
{
	static int test_time = 0;
	static int phase_to_hall[N_SIN] = { 0 };
	static int phase_index = 0;
	static int iterations = 0;
	static int done = 0;
	
	if(!done && mane_time > 5 * HZ && mane_time - test_time > 500)
	{
// store hall value from the previous phase index
		test_time = mane_time;
		phase_to_hall[phase_index] += hall.value;
		
		TRACE
		print_number(&uart, hall.value);
		print_fixed(&uart, phase_index * 360 * FRACTION / N_SIN);
		print_lf(&uart);

		phase_index++;
		if(phase_index >= N_SIN)
		{
			iterations++;
			phase_index = 0;
		}

// set new motor phase
		motor.phase = phase_index * 360 * FRACTION / N_SIN;
		write_motor();
// done
		if(iterations >= 1)
		{
			done = 1;


			int i;
			print_text(&uart, "\n\nconst char index_offset[] =\n{\n\t");

			for(i = 0; i < N_SIN; i++)
			{
//				TRACE
//				print_number(&uart, phase_to_hall[i] / iterations);
//				print_number(&uart, i * 360 / N_SIN);

// desired encoder value
				int want_hall = i * 
					(phase_to_hall[N_SIN - 1] - phase_to_hall[0]) /
					N_SIN + 
					phase_to_hall[0];

// required phase from measuring
				int j;
				int best_j;
				int best_diff;
				for(j = 0; j < N_SIN; j++)
				{
					int current_diff = ABS(phase_to_hall[j] - want_hall);
					if(j == 0 || best_diff > current_diff)
					{
						best_j = j;
						best_diff = current_diff;
					}
				}

//				print_number(&uart, want_hall / iterations);
//				print_number(&uart, best_j * 360 / N_SIN);

// convert to degrees
#if 1
				print_number_nospace(&uart, best_j - i);
				
				
				if(i < N_SIN - 1)
				{
					print_text(&uart, ", ");
				}

				if(i < N_SIN - 1 &&
					!((i + 1) % 16))
				{
					print_text(&uart, "\n\t");
				}
#endif

				flush_uart(&uart);
			}

			print_text(&uart, "\n};\n");
		}
	}
	
	
	
	
}
#endif // CALIBRATE_MOTOR


void init_motor()
{
	motor.deadband = MIN_DEADBAND;
	motor.phase = 0 * FRACTION;
	motor.power = MAX_POWER;
	motor.hall = 25000;
	init_derivative(&motor.derror, sizeof(motor.derror_prev) / sizeof(int));


	init_pid(&motor.pid,
		1 * FRACTION,  // P
		1, // I
		0, // D
		120 * FRACTION, // P limit
		120 * FRACTION, // I limit
		120 * FRACTION, // D limit
		120 * FRACTION, // out limit
		256); // I_DIVIDER


	int i;
	for(i = 0; i < N_SIN; i++)
	{
		int angle = 360 * FRACTION * i / N_SIN;
//      motor_table[i] = 0x7fff + sin_fixed(angle) * 0x7f;
      	motor_table[i] = 0x7fff + (sin_fixed14(angle) << 1);
//TRACE
//print_hex8(&uart, motor_table[i]);
	}
	


	TimHandle.Instance = TIM1;
	TimHandle.Init.Prescaler         = 0;
	TimHandle.Init.Period            = PERIOD;
	TimHandle.Init.ClockDivision     = 0;
	TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
	TimHandle.Init.RepetitionCounter = 0;
	HAL_TIM_PWM_Init(&TimHandle);


	sConfig.OCMode       = TIM_OCMODE_PWM1;
	sConfig.OCFastMode   = TIM_OCFAST_DISABLE;
	
	sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
	sConfig.OCIdleState  = TIM_OCIDLESTATE_SET;
	
	sConfig.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
	sConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	sConfig.Pulse = 0;


	HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_1);
	HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_2);
	HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_3);

	write_motor();

	TimHandle.Instance->BDTR = TIM_BDTR_MOE | TIM_BDTR_OSSI | motor.deadband;

	HAL_TIM_PWM_Start(&TimHandle, TIM_CHANNEL_1);
	HAL_TIMEx_PWMN_Start(&TimHandle, TIM_CHANNEL_1);
	
	HAL_TIM_PWM_Start(&TimHandle, TIM_CHANNEL_2);
	HAL_TIMEx_PWMN_Start(&TimHandle, TIM_CHANNEL_2);
	
	HAL_TIM_PWM_Start(&TimHandle, TIM_CHANNEL_3);
	HAL_TIMEx_PWMN_Start(&TimHandle, TIM_CHANNEL_3);
}


void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
  GPIO_InitTypeDef   GPIO_InitStruct;
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* TIMx Peripheral clock enable */
  __HAL_RCC_TIM1_CLK_ENABLE();

  /* Enable all GPIO Channels Clock requested */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;


  GPIO_InitStruct.Pin = (1 << N_MOSFET_PIN1) |
  	(1 << N_MOSFET_PIN2) |
  	(1 << N_MOSFET_PIN3);
  HAL_GPIO_Init(N_MOSFET_GPIO, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = (1 << P_MOSFET_PIN1) |
  	(1 << P_MOSFET_PIN2) |
  	(1 << P_MOSFET_PIN3);
  HAL_GPIO_Init(P_MOSFET_GPIO, &GPIO_InitStruct);

}





